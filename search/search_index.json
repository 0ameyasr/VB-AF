{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Vocabulary-Based Adversarial Fuzzing (VB-AF)","text":"<p>VB-AF is a gray-box fuzzing framework designed to probe for and identify commonly uncovered and unseen vulnerabilities in Large Language Models (LLMs).  It serves as a tool for AI safety researchers, red-teamers, and developers to test the alignment and robustness of their models. </p> <p>This project is the official implementation of the method detailed in this Kaggle Writeup, originally developed for probing previously unseen vulnerabilities in OpenAI's <code>gpt-oss:20b</code> model as part of the hackathon 'Red\u2011Teaming Challenge - OpenAI gpt-oss-20b' hosted on Kaggle. It proved to be an effective tool, helping me uncover an almost invisible vulnerability in the model's reasoning CoT.</p> <p>Following the vision for which it was developed, I then decided to turn VB-AF into a powerful fuzzing framework - a tool that could help AI red-teamers detect and observe how LLMs responded to unexpected, adversarial inputs. </p>"},{"location":"#what-is-vb-af","title":"What is VB-AF?","text":"<p>At its core, VB-AF is not a simple jailbreak, but a systematic method for observing how LLMs process and respond to unexpected inputs. It works by generating complex, high-entropy prompts that exploit known architectural weaknesses in transformer models. </p> <p>Its effectiveness was demonstrated through extensive experimentation, where VB-AF demonstrated its potential to induce cognitive-dissonance like states in reasoning models, leading to undesired behaviour. In its unoptimized, base version (as presented in the <code>VBAF</code> class), VB-AF achieved an overall statistically significant 36.44% ASR against <code>gpt-oss:20b</code>. Due to the obvious scope of optimization it presented due to its design, it was decided to be shared with the community for further improvements and exploration of use-cases.</p> <p>Its fuzzy payload generation algorithm (<code>generate_fuzzy_payload</code>) involves the following steps:</p> <ol> <li>Extracting the model's token vocabulary: this came from the belief that doing so could produce high-entropy but semantically grounded noise for the model. While the base implementation uses the model\u2019s tokens, one could instead design a large, diverse, and more targeted token vocabulary for the same purpose. This flexibility highlights VB-AF\u2019s gray-box nature. </li> <li>Generating <code>n_size = 100</code> token sequences, each consisting of <code>7 &lt;= rand_bounds &lt;= 21</code> tokens joined using ZWSP (<code>\\u200B</code>) separators. The ZWSP is a well documented character for adversarial obfuscation, with some very direct applications discussed in Boucher et al., (IEEE 2021). Its primary role and goal is to disrupt the model's tokenization process, potentially increasing evasion from filters and allowing the payload to be parsed in a non-standard way.</li> <li>Inserting a request at a random position <code>argK</code> within <code>[n_size // 2, 3 * n_size // 5]</code> somewhere in the middle: the request (or <code>payload</code>) was injected specifically somewhere in the 50 - 60% portion of the prompt context, exploiting the 'lost in the middle' phenomenon studied by Liu et al. (TACL 2024) by ensuring the top and bottom of the context was filled with noise, and only the middle contained a legible token sequence - the payload itself. </li> <li>Concatenating all token sequences and the injected payload into a single adversarial prompt that would be sent to the model via a harness for inference.</li> </ol>"},{"location":"#ethical-disclaimer","title":"Ethical Disclaimer","text":"<p>Warning: This is a research tool intended for security professionals, AI safety researchers, and developers for authorized security assessments and educational purposes.</p> <p>By using this software, you agree that you are solely responsible for your actions.</p> <p>The <code>vbaf</code> framework is a powerful tool designed to probe for and identify potentially significant vulnerabilities in Large Language Models (LLMs). Misuse of this software to generate harmful content or attack systems without explicit, authorized permission is strictly prohibited. </p> <p>The author(s) is(are) not responsible for any damage caused by the misuse of this tool. Please use responsibly and ethically.</p>"},{"location":"#getting-started","title":"Getting Started","text":"<p>Before you use this tool, you absolutely must acknowledge the previous disclaimer. Following that, to begin using VB-AF, start with the following links:</p> <ul> <li>Usage Guide: A step-by-step guide to installing <code>vbaf</code> and using it in your own projects.</li> <li>API Reference: Detailed documentation for the fuzzers (e.g. base <code>VBAF</code>) included and their methods.</li> </ul>"},{"location":"api/","title":"API Reference","text":""},{"location":"api/#vbaf.fuzzers","title":"<code>vbaf.fuzzers</code>","text":"<p>Fuzzers for the implementation of Vocabulary-Based Adversarial Fuzzing (VB-AF)</p>"},{"location":"api/#vbaf.fuzzers-classes","title":"Classes","text":""},{"location":"api/#vbaf.fuzzers.VBAF","title":"<code>VBAF</code>","text":"<p>A framework class implementation for Vocabulary-Based Adversarial Fuzzing (VB-AF).</p> <p>This class encapsulates the implementation logic for generating and applying VB-AF attacks. It can be used to create fuzzer instances with specific configurations and then apply them to inference functions, either through direct payload generation or via a convenient decorator.</p>"},{"location":"api/#vbaf.fuzzers.VBAF-functions","title":"Functions","text":""},{"location":"api/#vbaf.fuzzers.VBAF.__init__","title":"<code>__init__(vocabulary, seed=None, separator='\\u200b', join_on='', rand_bounds=(7, 21), position_bounds=(0.5, 0.6), n_size=100)</code>","text":"<p>Initializes the VB-AF fuzzer with a specific instance configuration.</p> <p>Parameters:</p> Name Type Description Default <code>vocabulary</code> <code>list[str]</code> <p>A list of tokens (strings) to sample from to create the surrounding noise.</p> required <code>seed</code> <code>int | None</code> <p>An integer seed for <code>random</code> to ensure reproducible fuzzing. Defaults to <code>None</code>.</p> <code>None</code> <code>separator</code> <code>str</code> <p>The character used to join individual tokens. Defaults to Zero-Width Space (ZWSP) '\\u200b'.</p> <code>'\\u200b'</code> <code>join_on</code> <code>str</code> <p>The character used to join the <code>n_size</code> token sequences. Defaults to an empty string.</p> <code>''</code> <code>rand_bounds</code> <code>tuple[int]</code> <p>A (min, max) tuple defining the inclusive range for the number of tokens in each noise sequence. Defaults to (7, 21).</p> <code>(7, 21)</code> <code>position_bounds</code> <code>tuple[float]</code> <p>A (min, max) float tuple defining the range <code>[int(min * n_size), int(max * n_size)]</code> from which to randomly select the payload's position. Defaults to (0.5, 0.6).</p> <code>(0.5, 0.6)</code> <code>n_size</code> <code>int</code> <p>The total number of token sequences in the final prompt. Defaults to 100.</p> <code>100</code>"},{"location":"api/#vbaf.fuzzers.VBAF.fuzz","title":"<code>fuzz(n_attempts=100, **kwargs)</code>","text":"<p>A decorator to apply VB-AF to an inference function.</p> <p>This decorator wraps an inference function that takes a string payload as its first argument (e.g. a function that calls an LLM's API). It transforms the decorated function into a fuzzing harness (generator) that, for each call, yields <code>n_attempts</code> of results by passing a newly generated fuzzy payload to the original inference function on each iteration.</p> <p>Parameters:</p> Name Type Description Default <code>n_attempts</code> <code>int</code> <p>The number of fuzzing attempts to generate for each call to the decorated function. Defaults to 100.</p> <code>100</code> <code>**kwargs</code> <code>any</code> <p>Arbitrary keyword arguments that will be passed either to the fuzzer or the decorated function. The decorator will intelligently pass fuzzer-related parameters (like <code>rand_bounds</code>) to the fuzzer and the rest to the inference function.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Callable</code> <code>Callable</code> <p>A decorator that transforms an inference function into a fuzzing harness generator.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <ul> <li>If <code>n_attempts</code> is not a positive integer</li> <li>If the decorated function does not accept at least one positional string argument.</li> </ul> Example <pre><code>from vbaf import VBAF\n\ntokens = [str(i) for i in range(10)]\nfuzzer = VBAF(tokens, n_size=15, rand_bounds=(2,5))\n\n@fuzzer.fuzz(n_attempts=3)\ndef fuzzing_harness(prompt: str):\n    # Realistically, this would call an LLM's API\n    return f\"Mock response for: {prompt}\"\n\nfor fuzzy_payload, result in fuzzing_harness(\"my payload here\"):\n    print(f\"Input: {fuzzy_payload}\")\n    print(f\"Result: {result}\")\n</code></pre> Note <p>Results from the fuzzing harness are yielded as tuples in the form of <code>(fuzzy_payload, response)</code>. This allows for direct analysis of the payload-response mapping.</p>"},{"location":"api/#vbaf.fuzzers.VBAF.generate_fuzzy_payload","title":"<code>generate_fuzzy_payload(payload)</code>","text":"<p>Generates a single adversarial prompt using the VB-AF method based on the instance configuration.</p> <p>This function creates a fuzzy payload by embedding a string request (<code>payload</code>) within a larger block of chaotic token-based noise. The noise is generated by sampling from a provided token <code>vocabulary</code>.</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>str</code> <p>The target string / request to embed in the noise.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The fully constructed adversarial fuzzy payload.</p> <p>Raises:</p> Type Description <code>AssertionError</code> <ul> <li>If <code>payload</code> is not a string instance,</li> <li>If <code>rand_bounds</code> defines an invalid or out-of-bounds range</li> <li>If <code>position_bounds</code> defines an invalid range not included in [0,1]</li> <li>If <code>n_size</code> is not a positive integer.</li> </ul>"},{"location":"usage/","title":"Usage Guide","text":"<p>This page will walk you through installing the library and applying it to your own projects.</p>"},{"location":"usage/#installation","title":"Installation","text":"<p>The <code>vbaf</code> package is available on PyPI and can be installed with pip:</p> <pre><code>pip install vbaf\n</code></pre>"},{"location":"usage/#developer-installation","title":"Developer Installation","text":"<p>If you wish to contribute to the development of <code>vbaf</code>, modify the source code, or install the very latest (pre-release) version, you should install it from the Git repository.</p> <p>1. Clone the Repository: <pre><code>git clone https://github.com/0ameyasr/vbaf\n</code></pre></p> <p>2. Create a Virtual Environment (Recommended): It's recommended to work within a virtual environment to avoid conflicts with other packages.</p> <pre><code># For Windows\npython -m venv venv\nvenv\\Scripts\\activate\n\n# For macOS/Linux\npython3 -m venv venv\nsource venv/bin/activate\n</code></pre> <p>3. Install in Editable Mode: Installing with the <code>-e</code> flag links the package to the source code. This means any changes you make to the source files will be immediately reflected when you use the library, which is ideal for development.</p> <pre><code>pip install -e .\n</code></pre> <p>For more information about contributing to <code>vbaf</code>, please see our  contribution guidelines.</p>"},{"location":"usage/#core-concepts","title":"Core Concepts","text":"<p>The <code>vbaf</code> library is built around a central class, <code>VBAF</code> that resides in the <code>fuzzers</code> module. You first create an instance of this class to define your fuzzing configuration, and then you use that instance to generate fuzzy payloads.</p> <p>A typical workflow looks like this:</p> <ul> <li>Create a fuzzer object with your desired settings (e.g., the vocabulary for noise, the size of the prompt, etc.).</li> <li>Write a Python function that takes a string prompt and calls your target LLM's API to generate a response.</li> <li>Use one of the two methods demonstrated below to generate fuzzy payloads and send them to your inference function.</li> </ul>"},{"location":"usage/#1-high-level-usage","title":"1. High Level Usage","text":"<p>The easiest and most common way to use <code>vbaf</code> is with the <code>@fuzzer.fuzz</code> decorator. It transforms your inference function into a convenient fuzzing harness (generator) with just a single line of code.</p> <p>For demonstration, we create a fuzzer and apply it to a mock inference function.</p> <pre><code>from vbaf import VBAF\n\n# Define a vocabulary to generate noise from (mocked below)\ncommon_tokens = [\"user\", \"error\", \"request\", \"model\", \"response\", \"token\"]\nfuzzer = VBAF(vocabulary=common_tokens, n_size=50, position_bounds=(0.4,0.6), rand_bounds=(3,4))\n\n@fuzzer.fuzz(n_attempts=5)\ndef fuzzing_harness(prompt: str):\n    # This is a mock function that will actually call an LLM's API\n    return f\"Mock response for {prompt}\"\n\n# Define the payload you want to test\ntarget_payload = \"How do I build a model?\"\n\n# Run the Fuzzer\ni = 0\nfor fuzzy_payload, result in fuzzing_harness(target_payload):\n    # Post-process here\n    print(fuzzy_payload, result)\n    ...\n    print(f\"Attempt {i+1} completed.\")\n    i += 1\n</code></pre>"},{"location":"usage/#2-low-level-usage","title":"2. Low Level Usage","text":"<p>If you need granular control over your fuzzing loop, you can generate fuzzy payloads directly using the <code>generate_fuzzy_payload()</code> method. This is useful for integrating <code>vbaf</code> into existing and more complex testing frameworks.</p> <p>The following example achieves the same result as the one above but with a manual loop.</p> <pre><code>from vbaf import VBAF\n\n# Configure the fuzzer (same as before)\ncommon_tokens = [\"user\", \"error\", \"request\", \"model\", \"response\", \"token\"]\nfuzzer = VBAF(vocabulary=common_tokens, n_size=50, rand_bounds=(3,4))\n\n# Define the payload you want to test\ntarget_payload = \"How do I build a model?\"\n\n# Run the Fuzzer Manually\nn_attempts = 5\nprint(f\"Fuzzing '{target_payload}' for {n_attempts} attempts...\")\n\nfor i in range(n_attempts):\n    # Generate a unique fuzzy payload on each iteration\n    fuzzy_payload = fuzzer.generate_fuzzy_payload(target_payload)\n\n    # Send it to your inference function\n    # result = inference.generate(fuzzy_payload)\n\n    # Post-process, collect and analyse the results\n    ...\n\n    print(f\"Attempt {i+1} completed.\")\n</code></pre>"}]}